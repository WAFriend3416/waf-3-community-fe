<!DOCTYPE html>
<!--
  Comment Item Fragment

  이 파일은 게시글 상세 페이지에서 사용되는 댓글 아이템 템플릿입니다.
  JavaScript 템플릿 함수로 동적 생성됩니다.

  사용 방법:
  scripts/board/detail.js의 createCommentItem() 함수에서 이 구조를 참조
-->

<!-- ========================================
     Comment Item Template
     ======================================== -->
<template id="comment-item-template">
  <div class="comment-item" data-comment-id="">
    <!-- Comment Header -->
    <div class="comment-item__header">
      <img
        src=""
        alt="작성자 프로필"
        class="comment-item__avatar"
        data-field="authorImage"
      >
      <div class="comment-item__info">
        <div class="comment-item__author" data-field="authorName">사용자</div>
        <div class="comment-item__date" data-field="createdAt">2024-01-01</div>
      </div>

      <!-- Actions (작성자만 표시) -->
      <div class="comment-item__actions" data-author-actions="" style="display: none;">
        <button class="comment-item__action" data-action="edit-comment">수정</button>
        <button class="comment-item__action comment-item__action--delete" data-action="delete-comment">삭제</button>
      </div>
    </div>

    <!-- Comment Content (읽기 모드) -->
    <div class="comment-item__content" data-field="content">
      댓글 내용이 여기에 표시됩니다.
    </div>

    <!-- Comment Edit Form (수정 모드, 기본 숨김) -->
    <div class="comment-item__edit-form" data-edit-form="" style="display: none;">
      <textarea
        class="comment-item__edit-textarea"
        data-field="editContent"
        placeholder="댓글을 입력하세요"
        rows="3"
      ></textarea>
      <div class="comment-item__edit-actions">
        <button class="btn btn--sm btn--secondary" data-action="cancel-edit">취소</button>
        <button class="btn btn--sm btn--primary" data-action="save-edit">저장</button>
      </div>
    </div>
  </div>
</template>

<!--
  JavaScript 사용 예시:

  // scripts/board/detail.js

  function createCommentItem(comment, currentUserId) {
    const template = document.getElementById('comment-item-template');
    const clone = template.content.cloneNode(true);
    const item = clone.querySelector('.comment-item');

    // Set comment ID
    item.setAttribute('data-comment-id', comment.commentId);

    // Author info
    const avatar = item.querySelector('[data-field="authorImage"]');
    avatar.src = comment.author.profileImage || '/images/default-avatar.png';

    const authorName = item.querySelector('[data-field="authorName"]');
    authorName.textContent = comment.author.nickname;

    const createdAt = item.querySelector('[data-field="createdAt"]');
    createdAt.textContent = Utils.formatDate(comment.createdAt);

    // Content
    const content = item.querySelector('[data-field="content"]');
    content.textContent = comment.content;

    // Show actions if current user is author
    if (currentUserId === comment.author.userId) {
      const actions = item.querySelector('[data-author-actions]');
      actions.style.display = 'flex';
    }

    return item;
  }

  // Usage:
  const commentItem = createCommentItem(commentData, currentUserId);
  commentList.appendChild(commentItem);
-->

<!-- ========================================
     Alternative: JavaScript Template Literal
     ======================================== -->
<!--
  // Pure JavaScript without HTML template

  function createCommentItemHTML(comment, currentUserId) {
    const {
      commentId,
      content,
      author,
      createdAt
    } = comment;

    const isAuthor = currentUserId === author.userId;
    const actionsDisplay = isAuthor ? 'flex' : 'none';

    return `
      <div class="comment-item" data-comment-id="${commentId}">
        <div class="comment-item__header">
          <img
            src="${author.profileImage || '/images/default-avatar.png'}"
            alt="${Utils.escapeHtml(author.nickname)} 프로필"
            class="comment-item__avatar"
          >
          <div class="comment-item__info">
            <div class="comment-item__author">${Utils.escapeHtml(author.nickname)}</div>
            <div class="comment-item__date">${Utils.formatDate(createdAt)}</div>
          </div>

          <div class="comment-item__actions" data-author-actions style="display: ${actionsDisplay};">
            <button class="comment-item__action" data-action="edit-comment">수정</button>
            <button class="comment-item__action comment-item__action--delete" data-action="delete-comment">삭제</button>
          </div>
        </div>

        <div class="comment-item__content">${Utils.escapeHtml(content)}</div>

        <div class="comment-item__edit-form" data-edit-form style="display: none;">
          <textarea
            class="comment-item__edit-textarea"
            data-field="editContent"
            placeholder="댓글을 입력하세요"
            rows="3"
          >${Utils.escapeHtml(content)}</textarea>
          <div class="comment-item__edit-actions">
            <button class="btn btn--sm btn--secondary" data-action="cancel-edit">취소</button>
            <button class="btn btn--sm btn--primary" data-action="save-edit">저장</button>
          </div>
        </div>
      </div>
    `;
  }

  // Usage:
  const html = createCommentItemHTML(commentData, currentUserId);
  commentList.insertAdjacentHTML('beforeend', html);
-->

<!-- ========================================
     Edit Mode Toggle Logic
     ======================================== -->
<!--
  // 수정 모드 전환

  function toggleEditMode(commentItem, isEditing) {
    const content = commentItem.querySelector('.comment-item__content');
    const editForm = commentItem.querySelector('[data-edit-form]');
    const actions = commentItem.querySelector('[data-author-actions]');

    if (isEditing) {
      // 수정 모드 진입
      content.style.display = 'none';
      editForm.style.display = 'flex';
      actions.style.display = 'none';
      commentItem.classList.add('comment-item--editing');

      // 기존 내용을 textarea에 설정
      const textarea = editForm.querySelector('[data-field="editContent"]');
      textarea.value = content.textContent;
      textarea.focus();
    } else {
      // 읽기 모드 복귀
      content.style.display = 'block';
      editForm.style.display = 'none';
      actions.style.display = 'flex';
      commentItem.classList.remove('comment-item--editing');
    }
  }

  // Event handlers
  function handleEditComment(e) {
    const commentItem = e.target.closest('.comment-item');
    toggleEditMode(commentItem, true);
  }

  function handleCancelEdit(e) {
    const commentItem = e.target.closest('.comment-item');
    toggleEditMode(commentItem, false);
  }

  async function handleSaveEdit(e) {
    const commentItem = e.target.closest('.comment-item');
    const commentId = commentItem.getAttribute('data-comment-id');
    const textarea = commentItem.querySelector('[data-field="editContent"]');
    const newContent = textarea.value.trim();

    if (!newContent) {
      Utils.toast.error('댓글 내용을 입력해주세요');
      return;
    }

    try {
      const result = await API.put(`/comments/${commentId}`, {
        content: newContent
      });

      if (result.success) {
        // Update content in DOM
        const contentDiv = commentItem.querySelector('.comment-item__content');
        contentDiv.textContent = newContent;

        // Exit edit mode
        toggleEditMode(commentItem, false);

        Utils.toast.success('댓글이 수정되었습니다');
      }
    } catch (error) {
      Utils.toast.error('댓글 수정에 실패했습니다');
    }
  }

  async function handleDeleteComment(e) {
    const commentItem = e.target.closest('.comment-item');
    const commentId = commentItem.getAttribute('data-comment-id');

    const confirmed = await Utils.modal.confirm(
      '댓글 삭제',
      '정말 이 댓글을 삭제하시겠습니까?'
    );

    if (!confirmed) return;

    try {
      const result = await API.delete(`/comments/${commentId}`);

      if (result.success) {
        commentItem.remove();
        Utils.toast.success('댓글이 삭제되었습니다');
      }
    } catch (error) {
      Utils.toast.error('댓글 삭제에 실패했습니다');
    }
  }
-->
